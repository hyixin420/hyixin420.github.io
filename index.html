<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Dæ‰‹åŠ¿åœ£è¯æ ‘ | ç…§ç‰‡å¢™ç‰ˆ</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #000000; 
            color: #FFD700; 
            font-family: 'Arial', sans-serif; 
            overflow: hidden; 
            height: 100vh; 
        }
        
        .header {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }
        
        h1 {
            font-size: 2rem;
            background: linear-gradient(45deg, #FFD700, #FFF8DC);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 5px;
        }
        
        #sceneContainer {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        /* å·¦ä¾§æ§åˆ¶é¢æ¿ */
        .control-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #FFD700;
            z-index: 100;
            width: 280px;
            backdrop-filter: blur(10px);
            box-shadow: 0 5px 20px rgba(255,215,0,0.2);
        }
        
        .panel-title {
            color: #FFD700;
            margin-bottom: 15px;
            font-size: 1.1rem;
            border-bottom: 1px solid rgba(255,215,0,0.3);
            padding-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .panel-title::before {
            content: "ğŸ„";
        }
        
        .upload-section {
            margin-bottom: 20px;
        }
        
        .upload-btn {
            display: block;
            width: 100%;
            padding: 12px;
            background: linear-gradient(45deg, #D4AF37, #FFD700);
            color: #000;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            text-align: center;
            transition: all 0.3s;
            margin-bottom: 10px;
        }
        
        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255,215,0,0.4);
        }
        
        .photo-count {
            color: #FFF8DC;
            font-size: 0.9rem;
            margin-top: 10px;
            text-align: center;
        }
        
        .photo-list {
            max-height: 150px;
            overflow-y: auto;
            margin-top: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            border: 1px solid rgba(255,215,0,0.2);
        }
        
        .photo-item {
            display: flex;
            align-items: center;
            padding: 5px;
            margin-bottom: 5px;
            background: rgba(255,215,0,0.1);
            border-radius: 5px;
            font-size: 0.8rem;
        }
        
        .photo-item:hover {
            background: rgba(255,215,0,0.2);
        }
        
        .photo-item::before {
            content: "ğŸ–¼ï¸";
            margin-right: 8px;
        }
        
        .control-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        
        .control-btn {
            padding: 10px;
            background: rgba(255,215,0,0.15);
            color: #FFD700;
            border: 1px solid #FFD700;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s;
        }
        
        .control-btn:hover {
            background: rgba(255,215,0,0.3);
            transform: translateY(-2px);
        }
        
        .control-btn.delete {
            background: rgba(255,50,50,0.15);
            border-color: #FF3333;
            color: #FF6666;
        }
        
        .control-btn.delete:hover {
            background: rgba(255,50,50,0.3);
        }
        
        /* å³ä¾§çŠ¶æ€é¢æ¿ */
        .status-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #FFD700;
            z-index: 100;
            width: 280px;
            backdrop-filter: blur(10px);
            box-shadow: 0 5px 20px rgba(255,215,0,0.2);
        }
        
        .status-item {
            margin-bottom: 15px;
        }
        
        .status-label {
            color: #FFF8DC;
            font-size: 0.9rem;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-label::before {
            font-size: 1rem;
        }
        
        .status-value {
            color: #FFD700;
            font-size: 1rem;
            font-weight: bold;
            padding: 8px;
            background: rgba(255,215,0,0.1);
            border-radius: 6px;
            display: block;
            text-align: center;
        }
        
        #gestureStatus {
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
        }
        
        /* æ‘„åƒå¤´é¢æ¿ */
        .camera-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-radius: 15px;
            border: 2px solid #FFD700;
            z-index: 100;
            text-align: center;
            width: 220px;
            backdrop-filter: blur(10px);
        }
        
        #webcam {
            width: 180px;
            height: 135px;
            border-radius: 8px;
            border: 2px solid #FFD700;
            transform: scaleX(-1);
            background: #000;
        }
        
        /* ç…§ç‰‡å¢™æ¨¡å¼æç¤º */
        .photo-wall-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 10px;
            border: 1px solid #FFD700;
            z-index: 100;
            font-size: 0.9rem;
            color: #FFF8DC;
            display: none;
        }
        
        /* åŠ è½½æŒ‡ç¤ºå™¨ */
        .loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #FFD700;
            z-index: 200;
            text-align: center;
            color: #FFD700;
            font-size: 1.2rem;
        }
        
        .loader.hidden {
            display: none;
        }
        
        /* å“åº”å¼è°ƒæ•´ */
        @media (max-width: 1200px) {
            .control-panel, .status-panel {
                width: 240px;
            }
        }
        
        @media (max-width: 900px) {
            .control-panel, .status-panel {
                position: relative;
                width: 90%;
                margin: 10px auto;
                left: 0;
                right: 0;
                transform: none;
            }
            
            .camera-panel {
                width: 200px;
            }
            
            #webcam {
                width: 160px;
                height: 120px;
            }
        }
    </style>
</head>
<body>
    <!-- æ ‡é¢˜ -->
    <div class="header">
        <h1>ğŸ„ 3Dç…§ç‰‡åœ£è¯æ ‘ ğŸ„</h1>
        <div style="font-size: 0.9rem;">ä¸Šä¼ ç…§ç‰‡ | æ‰‹åŠ¿æ§åˆ¶ | 3Dç…§ç‰‡å¢™</div>
    </div>
    
    <!-- å·¦ä¾§æ§åˆ¶é¢æ¿ -->
    <div class="control-panel">
        <div class="panel-title">ç…§ç‰‡æ§åˆ¶é¢æ¿</div>
        
        <div class="upload-section">
            <label for="photoUpload" class="upload-btn">
                ğŸ“· ä¸Šä¼ ç…§ç‰‡ (å¯å¤šé€‰)
            </label>
            <input type="file" id="photoUpload" accept="image/*" multiple style="display: none;">
            
            <div class="photo-count">
                å·²åŠ è½½: <span id="photoCount">0</span> å¼ ç…§ç‰‡
            </div>
            
            <div class="photo-list" id="photoList">
                <!-- ç…§ç‰‡åˆ—è¡¨ä¼šåŠ¨æ€æ·»åŠ åˆ°è¿™é‡Œ -->
            </div>
        </div>
        
        <div class="control-buttons">
            <button class="control-btn" onclick="tree.togglePhotoWall()">
                ğŸ–¼ï¸ åˆ‡æ¢ç…§ç‰‡å¢™
            </button>
            <button class="control-btn" onclick="tree.rotatePhotos()">
                ğŸ”„ æ—‹è½¬ç…§ç‰‡
            </button>
            <button class="control-btn" onclick="tree.scatterParticles()">
                âœ¨ ç²’å­æ•£å¼€
            </button>
            <button class="control-btn delete" onclick="tree.clearAllPhotos()">
                ğŸ—‘ï¸ æ¸…ç©ºç…§ç‰‡
            </button>
        </div>
    </div>
    
    <!-- å³ä¾§çŠ¶æ€é¢æ¿ -->
    <div class="status-panel">
        <div class="panel-title">ç³»ç»ŸçŠ¶æ€</div>
        
        <div class="status-item">
            <div class="status-label">ğŸŒ² åœ£è¯æ ‘æ¨¡å¼</div>
            <div class="status-value" id="treeMode">æ ‘å½¢</div>
        </div>
        
        <div class="status-item">
            <div class="status-label">ğŸ¯ ç…§ç‰‡å¢™çŠ¶æ€</div>
            <div class="status-value" id="photoWallStatus">å…³é—­</div>
        </div>
        
        <div class="status-item">
            <div class="status-label">âœ‹ æ‰‹åŠ¿çŠ¶æ€</div>
            <div class="status-value" id="gestureStatus">
                ç­‰å¾…æ‘„åƒå¤´å¯åŠ¨
            </div>
        </div>
        
        <div class="status-item">
            <div class="status-label">âš™ï¸ æ“ä½œæç¤º</div>
            <div class="status-value" style="font-size:0.85rem;">
                æ¡æ‹³èšåˆ | å¼ å¼€æ•£å¼€
            </div>
        </div>
    </div>
    
    <!-- æ‘„åƒå¤´é¢æ¿ -->
    <div class="camera-panel">
        <div style="margin-bottom: 10px; color: #FFD700;">ğŸ¥ æ‰‹åŠ¿æ‘„åƒå¤´</div>
        <video id="webcam" autoplay playsinline></video>
        <button onclick="startCamera()" class="control-btn" style="margin-top:10px; width:100%;">
            å¯åŠ¨æ‘„åƒå¤´
        </button>
    </div>
    
    <!-- ç…§ç‰‡å¢™æ¨¡å¼æç¤º -->
    <div class="photo-wall-hint" id="photoWallHint">
        ğŸ–¼ï¸ ç…§ç‰‡å¢™æ¨¡å¼å·²æ¿€æ´»ï¼ç…§ç‰‡æ­£åœ¨å›´ç»•åœ£è¯æ ‘æ—‹è½¬
    </div>
    
    <!-- åŠ è½½æŒ‡ç¤ºå™¨ -->
    <div class="loader" id="loader">
        <div>ğŸ”„ åŠ è½½åœ£è¯æ ‘ä¸­...</div>
        <div style="font-size:0.9rem; margin-top:10px;" id="loadProgress"></div>
    </div>
    
    <!-- 3Dåœºæ™¯å®¹å™¨ -->
    <div id="sceneContainer"></div>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // å¸¦ç…§ç‰‡å¢™çš„åœ£è¯æ ‘
        class PhotoChristmasTree {
            constructor() {
                // Three.jsæ ¸å¿ƒ
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                
                // ç²’å­ç³»ç»Ÿ
                this.particles = [];
                this.particleGroup = new THREE.Group();
                this.targetPositions = [];
                
                // ç…§ç‰‡ç³»ç»Ÿ
                this.photos = []; // å­˜å‚¨ç…§ç‰‡æ•°æ®
                this.photoCards = []; // å­˜å‚¨3Dç…§ç‰‡å¡ç‰‡
                this.isPhotoWallActive = false;
                this.photoWallRadius = 15;
                
                // æ§åˆ¶çŠ¶æ€
                this.mode = 'tree';
                this.isRotating = true;
                this.colorTheme = 0;
                
                // æ‰‹åŠ¿æ§åˆ¶
                this.video = null;
                this.canvas = null;
                this.ctx = null;
                this.handTrackingActive = false;
                this.lastHandX = 0.5;
                this.lastHandY = 0.5;
                this.gestureCooldown = 0;
                
                // å‚æ•°
                this.params = {
                    particleCount: 1000,
                    treeHeight: 12,
                    treeRadius: 4,
                    handDetectionThreshold: 40
                };
                
                this.init();
            }
            
            async init() {
                console.log("ğŸ„ åˆå§‹åŒ–å¸¦ç…§ç‰‡å¢™çš„åœ£è¯æ ‘...");
                
                // æ˜¾ç¤ºåŠ è½½è¿›åº¦
                this.updateLoadProgress("åˆ›å»º3Dåœºæ™¯...");
                
                // 1. åˆ›å»ºåœºæ™¯
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x000000);
                this.scene.fog = new THREE.Fog(0x000000, 10, 50);
                
                // 2. åˆ›å»ºç›¸æœº
                this.camera = new THREE.PerspectiveCamera(
                    60, 
                    window.innerWidth / window.innerHeight,
                    0.1, 
                    1000
                );
                this.camera.position.set(0, 8, 25);
                
                this.updateLoadProgress("åˆ›å»ºæ¸²æŸ“å™¨...");
                
                // 3. åˆ›å»ºæ¸²æŸ“å™¨
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    alpha: false
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('sceneContainer').appendChild(this.renderer.domElement);
                
                // 4. è®¾ç½®ç¯å…‰
                this.setupLights();
                
                this.updateLoadProgress("åˆ›å»ºç²’å­ç³»ç»Ÿ...");
                
                // 5. åˆ›å»ºåœ£è¯æ ‘ç²’å­
                this.createParticles();
                
                // 6. è®¾ç½®UIäº‹ä»¶
                this.setupUI();
                
                // 7. è®¾ç½®é¼ æ ‡æ§åˆ¶
                this.setupMouseControls();
                
                // 8. å¼€å§‹åŠ¨ç”»å¾ªç¯
                this.animate();
                
                // 9. éšè—åŠ è½½å™¨
                setTimeout(() => {
                    document.getElementById('loader').classList.add('hidden');
                    document.getElementById('status').textContent = 'å°±ç»ª';
                }, 1000);
                
                console.log("âœ… åˆå§‹åŒ–å®Œæˆï¼");
            }
            
            updateLoadProgress(message) {
                const progress = document.getElementById('loadProgress');
                if (progress) {
                    progress.textContent = message;
                }
            }
            
            setupLights() {
                // ç¯å¢ƒå…‰
                const ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.4);
                this.scene.add(ambientLight);
                
                // ä¸»èšå…‰ç¯ï¼ˆé‡‘è‰²ï¼‰
                const mainLight = new THREE.SpotLight(0xFFD700, 1.2);
                mainLight.position.set(10, 20, 10);
                mainLight.angle = Math.PI / 4;
                mainLight.penumbra = 0.5;
                mainLight.decay = 2;
                mainLight.distance = 100;
                mainLight.castShadow = true;
                mainLight.shadow.mapSize.width = 1024;
                mainLight.shadow.mapSize.height = 1024;
                this.scene.add(mainLight);
                
                // ç‚¹å…‰æºï¼ˆç”¨äºç…§ç‰‡ç…§æ˜ï¼‰
                const photoLight = new THREE.PointLight(0xFFFFFF, 0.8, 50);
                photoLight.position.set(0, 10, 0);
                this.scene.add(photoLight);
            }
            
            createParticles() {
                console.log("åˆ›å»ºåœ£è¯æ ‘ç²’å­...");
                
                // ä¸¤ç§å‡ ä½•ä½“ï¼šç«‹æ–¹ä½“å’Œçƒä½“
                const geometries = [
                    new THREE.BoxGeometry(0.2, 0.2, 0.2),
                    new THREE.SphereGeometry(0.15, 6, 6)
                ];
                
                // ä¸¤ç§æè´¨ï¼šé‡‘è‰²å’Œå¥¶æ²¹è‰²
                const goldMaterial = new THREE.MeshStandardMaterial({
                    color: 0xFFD700,
                    metalness: 0.8,
                    roughness: 0.2,
                    emissive: 0xFFD700,
                    emissiveIntensity: 0.3
                });
                
                const creamMaterial = new THREE.MeshStandardMaterial({
                    color: 0xFFF8DC,
                    metalness: 0.4,
                    roughness: 0.3,
                    emissive: 0xFFF8DC,
                    emissiveIntensity: 0.2
                });
                
                const materials = [goldMaterial, creamMaterial];
                
                // åˆ›å»ºç²’å­
                for (let i = 0; i < this.params.particleCount; i++) {
                    const geometry = geometries[Math.floor(Math.random() * geometries.length)];
                    const material = materials[Math.floor(Math.random() * materials.length)];
                    const particle = new THREE.Mesh(geometry, material.clone());
                    
                    // éšæœºåˆå§‹ä½ç½®ï¼ˆçƒå½¢åˆ†å¸ƒï¼‰
                    const radius = 18;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    
                    particle.position.x = radius * Math.sin(phi) * Math.cos(theta);
                    particle.position.y = radius * Math.sin(phi) * Math.sin(theta);
                    particle.position.z = radius * Math.cos(phi);
                    
                    // éšæœºæ—‹è½¬
                    particle.rotation.x = Math.random() * Math.PI * 2;
                    particle.rotation.y = Math.random() * Math.PI * 2;
                    
                    // å­˜å‚¨ç²’å­æ•°æ®
                    particle.userData = {
                        targetPosition: new THREE.Vector3(),
                        originalIndex: i,
                        speed: 0.3 + Math.random() * 0.4,
                        scale: 0.8 + Math.random() * 0.4
                    };
                    
                    particle.scale.setScalar(particle.userData.scale);
                    particle.castShadow = true;
                    
                    this.particles.push(particle);
                    this.particleGroup.add(particle);
                }
                
                // è®¡ç®—åœ£è¯æ ‘å½¢çŠ¶
                this.calculateTreePositions();
                this.scene.add(this.particleGroup);
                
                // æ›´æ–°UI
                document.getElementById('treeMode').textContent = 'æ ‘å½¢';
                document.getElementById('photoCount').textContent = '0';
            }
            
            calculateTreePositions() {
                this.targetPositions = [];
                
                for (let i = 0; i < this.particles.length; i++) {
                    const layerCount = 8;
                    const layer = Math.floor((i / this.particles.length) * layerCount);
                    const layerHeight = this.params.treeHeight * (layer / layerCount);
                    const layerRadius = this.params.treeRadius * (1 - (layer / layerCount));
                    
                    // é»„é‡‘è§’åº¦èºæ—‹æ’åˆ—
                    const angle = (i * 137.5) * (Math.PI / 180);
                    const radius = layerRadius * Math.sqrt((i % (this.particles.length / layerCount)) / (this.particles.length / layerCount));
                    
                    const targetPos = new THREE.Vector3(
                        Math.cos(angle) * radius,
                        layerHeight,
                        Math.sin(angle) * radius
                    );
                    
                    this.targetPositions.push(targetPos);
                    this.particles[i].userData.targetPosition.copy(targetPos);
                }
            }
            
            // ==================== ç…§ç‰‡ä¸Šä¼ åŠŸèƒ½ ====================
            setupUI() {
                // ç…§ç‰‡ä¸Šä¼ å¤„ç†
                document.getElementById('photoUpload').addEventListener('change', (event) => {
                    this.handlePhotoUpload(event.target.files);
                    event.target.value = ''; // é‡ç½®input
                });
                
                // ç‚¹å‡»ä¸Šä¼ æŒ‰é’®
                document.querySelector('.upload-btn').addEventListener('click', () => {
                    document.getElementById('photoUpload').click();
                });
                
                // åˆå§‹æ›´æ–°
                this.updatePhotoList();
            }
            
            async handlePhotoUpload(files) {
                console.log(`ä¸Šä¼  ${files.length} å¼ ç…§ç‰‡`);
                
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    
                    try {
                        // è¯»å–æ–‡ä»¶ä¸ºDataURL
                        const dataUrl = await this.readFileAsDataURL(file);
                        
                        // æ·»åŠ åˆ°ç…§ç‰‡æ•°ç»„
                        this.photos.push({
                            id: Date.now() + i,
                            name: file.name,
                            dataUrl: dataUrl,
                            size: file.size,
                            type: file.type
                        });
                        
                        // åˆ›å»º3Dç…§ç‰‡å¡ç‰‡
                        await this.createPhotoCard(dataUrl, this.photos.length - 1);
                        
                    } catch (error) {
                        console.error('ç…§ç‰‡å¤„ç†å¤±è´¥:', error);
                    }
                }
                
                // æ›´æ–°UI
                this.updatePhotoList();
                this.updatePhotoCount();
                
                // å¦‚æœç…§ç‰‡å¢™æœªæ¿€æ´»ä½†æœ‰å¤šå¼ ç…§ç‰‡ï¼Œæç¤ºç”¨æˆ·
                if (this.photos.length >= 2 && !this.isPhotoWallActive) {
                    this.showPhotoWallHint();
                }
            }
            
            readFileAsDataURL(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = (e) => reject(e);
                    reader.readAsDataURL(file);
                });
            }
            
            async createPhotoCard(dataUrl, photoIndex) {
                return new Promise((resolve) => {
                    const img = new Image();
                    
                    img.onload = () => {
                        // åˆ›å»ºçº¹ç†
                        const texture = new THREE.Texture();
                        texture.image = img;
                        texture.needsUpdate = true;
                        
                        // è®¡ç®—ä¿æŒæ¯”ä¾‹çš„å°ºå¯¸
                        const maxWidth = 4;
                        const maxHeight = 3;
                        const ratio = img.width / img.height;
                        
                        let width = maxWidth;
                        let height = maxWidth / ratio;
                        
                        if (height > maxHeight) {
                            height = maxHeight;
                            width = maxHeight * ratio;
                        }
                        
                        // åˆ›å»ºç…§ç‰‡å¡ç‰‡å‡ ä½•ä½“
                        const geometry = new THREE.PlaneGeometry(width, height);
                        
                        // åˆ›å»ºæè´¨
                        const material = new THREE.MeshStandardMaterial({
                            map: texture,
                            side: THREE.DoubleSide,
                            transparent: true,
                            opacity: 0.9,
                            roughness: 0.3,
                            metalness: 0.1
                        });
                        
                        // åˆ›å»ºç½‘æ ¼
                        const photoCard = new THREE.Mesh(geometry, material);
                        
                        // è®¾ç½®ä½ç½®ï¼ˆå›´ç»•åœ£è¯æ ‘ï¼‰
                        const angle = (photoIndex / Math.max(1, this.photos.length)) * Math.PI * 2;
                        const radius = this.photoWallRadius;
                        const heightOffset = 6;
                        
                        photoCard.position.set(
                            Math.cos(angle) * radius,
                            heightOffset,
                            Math.sin(angle) * radius
                        );
                        
                        // å§‹ç»ˆé¢å‘ç›¸æœºï¼ˆå¹¿å‘Šç‰Œæ•ˆæœï¼‰
                        photoCard.lookAt(this.camera.position);
                        
                        // æ·»åŠ è¾¹æ¡†æ•ˆæœ
                        const borderGeometry = new THREE.PlaneGeometry(width + 0.2, height + 0.2);
                        const borderMaterial = new THREE.MeshBasicMaterial({
                            color: 0xFFD700,
                            side: THREE.DoubleSide,
                            transparent: true,
                            opacity: 0.5
                        });
                        
                        const border = new THREE.Mesh(borderGeometry, borderMaterial);
                        border.position.z = -0.01; // ç¨å¾®åœ¨åé¢
                        photoCard.add(border);
                        
                        // æ·»åŠ å‘å…‰æ•ˆæœ
                        const glowGeometry = new THREE.PlaneGeometry(width + 0.4, height + 0.4);
                        const glowMaterial = new THREE.MeshBasicMaterial({
                            color: 0xFFD700,
                            side: THREE.DoubleSide,
                            transparent: true,
                            opacity: 0.2
                        });
                        
                        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                        glow.position.z = -0.02;
                        photoCard.add(glow);
                        
                        // å­˜å‚¨å¼•ç”¨
                        photoCard.userData = {
                            isPhotoCard: true,
                            photoIndex: photoIndex,
                            originalAngle: angle,
                            rotationSpeed: 0.002 + Math.random() * 0.003,
                            bobSpeed: 0.5 + Math.random() * 0.5,
                            bobHeight: 0.1 + Math.random() * 0.2
                        };
                        
                        // æ·»åŠ åˆ°åœºæ™¯å’Œæ•°ç»„
                        this.scene.add(photoCard);
                        this.photoCards.push(photoCard);
                        
                        console.log(`âœ… åˆ›å»ºç…§ç‰‡å¡ç‰‡ #${photoIndex + 1}`);
                        resolve();
                    };
                    
                    img.src = dataUrl;
                });
            }
            
            updatePhotoList() {
                const photoList = document.getElementById('photoList');
                photoList.innerHTML = '';
                
                this.photos.forEach((photo, index) => {
                    const item = document.createElement('div');
                    item.className = 'photo-item';
                    item.title = `${photo.name} (${Math.round(photo.size/1024)}KB)`;
                    item.textContent = `${index + 1}. ${photo.name.substring(0, 20)}${photo.name.length > 20 ? '...' : ''}`;
                    
                    // ç‚¹å‡»èšç„¦ç…§ç‰‡
                    item.addEventListener('click', () => {
                        this.focusOnPhoto(index);
                    });
                    
                    photoList.appendChild(item);
                });
                
                // æ»šåŠ¨åˆ°åº•éƒ¨
                photoList.scrollTop = photoList.scrollHeight;
            }
            
            updatePhotoCount() {
                document.getElementById('photoCount').textContent = this.photos.length;
            }
            
            // ==================== ç…§ç‰‡å¢™æ§åˆ¶ ====================
            togglePhotoWall() {
                this.isPhotoWallActive = !this.isPhotoWallActive;
                
                const status = document.getElementById('photoWallStatus');
                const hint = document.getElementById('photoWallHint');
                
                if (this.isPhotoWallActive) {
                    status.textContent = 'æ¿€æ´»';
                    status.style.color = '#4CAF50';
                    hint.style.display = 'block';
                    
                    // æ¿€æ´»ç…§ç‰‡å¢™æ—¶ï¼Œè°ƒæ•´ç…§ç‰‡ä½ç½®
                    this.arrangePhotosInWall();
                    
                    setTimeout(() => {
                        hint.style.display = 'none';
                    }, 3000);
                    
                } else {
                    status.textContent = 'å…³é—­';
                    status.style.color = '#FFD700';
                    hint.style.display = 'none';
                    
                    // å…³é—­æ—¶é‡ç½®ç…§ç‰‡ä½ç½®
                    this.resetPhotoPositions();
                }
            }
            
            arrangePhotosInWall() {
                this.photoCards.forEach((card, index) => {
                    const angle = (index / this.photoCards.length) * Math.PI * 2;
                    const radius = this.photoWallRadius;
                    
                    card.userData.targetPosition = new THREE.Vector3(
                        Math.cos(angle) * radius,
                        6 + Math.sin(Date.now() * 0.001 + index) * 0.5,
                        Math.sin(angle) * radius
                    );
                    
                    card.userData.targetLookAt = new THREE.Vector3(0, 6, 0);
                });
            }
            
            resetPhotoPositions() {
                this.photoCards.forEach((card, index) => {
                    const angle = (index / this.photoCards.length) * Math.PI * 2;
                    const radius = 12;
                    
                    card.userData.targetPosition = new THREE.Vector3(
                        Math.cos(angle) * radius,
                        5,
                        Math.sin(angle) * radius
                    );
                    
                    card.userData.targetLookAt = this.camera.position.clone();
                });
            }
            
            rotatePhotos() {
                // éšæœºæ—‹è½¬æ‰€æœ‰ç…§ç‰‡
                this.photoCards.forEach(card => {
                    card.rotation.y += (Math.random() - 0.5) * 0.5;
                    card.rotation.x += (Math.random() - 0.5) * 0.3;
                });
            }
            
            focusOnPhoto(photoIndex) {
                if (photoIndex >= 0 && photoIndex < this.photoCards.length) {
                    const photoCard = this.photoCards[photoIndex];
                    
                    // ä¿å­˜å½“å‰ç›¸æœºä½ç½®
                    const originalPosition = this.camera.position.clone();
                    const originalLookAt = new THREE.Vector3(0, 0, 0);
                    
                    // è®¡ç®—ç›®æ ‡ä½ç½®ï¼ˆç…§ç‰‡å‰æ–¹ï¼‰
                    const targetPosition = photoCard.position.clone();
                    targetPosition.z += 8;
                    targetPosition.y += 2;
                    
                    // åŠ¨ç”»ç§»åŠ¨åˆ°ç…§ç‰‡
                    const duration = 1500;
                    const startTime = Date.now();
                    
                    const animateCamera = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        
                        // ç¼“åŠ¨å‡½æ•°
                        const easeProgress = this.easeOutCubic(progress);
                        
                        // æ’å€¼ç›¸æœºä½ç½®
                        this.camera.position.lerpVectors(originalPosition, targetPosition, easeProgress);
                        
                        // çœ‹å‘ç…§ç‰‡
                        this.camera.lookAt(photoCard.position);
                        
                        if (progress < 1) {
                            requestAnimationFrame(animateCamera);
                        } else {
                            // 3ç§’åè¿”å›
                            setTimeout(() => {
                                this.returnCameraToOriginal(originalPosition);
                            }, 3000);
                        }
                    };
                    
                    animateCamera();
                }
            }
            
            returnCameraToOriginal(originalPosition) {
                const currentPosition = this.camera.position.clone();
                const duration = 1500;
                const startTime = Date.now();
                
                const animateReturn = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const easeProgress = this.easeOutCubic(progress);
                    
                    this.camera.position.lerpVectors(currentPosition, originalPosition, easeProgress);
                    this.camera.lookAt(0, 6, 0);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateReturn);
                    }
                };
                
                animateReturn();
            }
            
            easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }
            
            clearAllPhotos() {
                if (confirm('ç¡®å®šè¦åˆ é™¤æ‰€æœ‰ç…§ç‰‡å—ï¼Ÿ')) {
                    // ä»åœºæ™¯ä¸­ç§»é™¤æ‰€æœ‰ç…§ç‰‡å¡ç‰‡
                    this.photoCards.forEach(card => {
                        this.scene.remove(card);
                    });
                    
                    // æ¸…ç©ºæ•°ç»„
                    this.photos = [];
                    this.photoCards = [];
                    
                    // æ›´æ–°UI
                    this.updatePhotoList();
                    this.updatePhotoCount();
                    
                    console.log('ğŸ—‘ï¸ å·²æ¸…ç©ºæ‰€æœ‰ç…§ç‰‡');
                }
            }
            
            // ==================== ç²’å­æ§åˆ¶ ====================
            scatterParticles() {
                if (this.mode === 'scattered') return;
                
                this.mode = 'scattered';
                document.getElementById('treeMode').textContent = 'æ•£å¼€';
                
                for (let i = 0; i < this.particles.length; i++) {
                    const radius = 12 + Math.random() * 8;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    
                    this.particles[i].userData.targetPosition.set(
                        radius * Math.sin(phi) * Math.cos(theta),
                        radius * Math.sin(phi) * Math.sin(theta),
                        radius * Math.cos(phi)
                    );
                }
            }
            
            formTree() {
                if (this.mode === 'tree') return;
                
                this.mode = 'tree';
                document.getElementById('treeMode').textContent = 'æ ‘å½¢';
                
                for (let i = 0; i < this.particles.length; i++) {
                    this.particles[i].userData.targetPosition.copy(this.targetPositions[i]);
                }
            }
            
            toggleRotation() {
                this.isRotating = !this.isRotating;
            }
            
            changeColor() {
                this.colorTheme = (this.colorTheme + 1) % 3;
                
                const colors = [
                    { main: 0xFFD700, name: 'é‡‘è‰²' },
                    { main: 0xFF3333, name: 'çº¢è‰²' },
                    { main: 0x3366FF, name: 'è“è‰²' }
                ];
                
                const color = colors[this.colorTheme];
                
                this.particles.forEach(particle => {
                    particle.material.color.setHex(color.main);
                    particle.material.emissive.setHex(color.main);
                });
            }
            
            showPhotoWallHint() {
                const hint = document.getElementById('photoWallHint');
                hint.style.display = 'block';
                hint.textContent = 'ğŸ–¼ï¸ å·²ä¸Šä¼ å¤šå¼ ç…§ç‰‡ï¼Œç‚¹å‡»"åˆ‡æ¢ç…§ç‰‡å¢™"æŸ¥çœ‹æ•ˆæœï¼';
                
                setTimeout(() => {
                    hint.style.display = 'none';
                }, 5000);
            }
            
            // ==================== æ‰‹åŠ¿æ§åˆ¶ ====================
            async setupCamera() {
                try {
                    this.video = document.getElementById('webcam');
                    
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: true 
                    });
                    
                    this.video.srcObject = stream;
                    
                    await new Promise(resolve => {
                        this.video.onloadedmetadata = () => {
                            this.video.play();
                            resolve();
                        };
                    });
                    
                    this.canvas = document.createElement('canvas');
                    this.ctx = this.canvas.getContext('2d');
                    this.canvas.width = 80;
                    this.canvas.height = 60;
                    
                    document.getElementById('gestureStatus').textContent = 'ğŸ‘‹ æ‘„åƒå¤´å°±ç»ªï¼å°è¯•æ‰‹åŠ¿';
                    this.handTrackingActive = true;
                    
                    this.startSimpleHandDetection();
                    
                } catch (error) {
                    console.log('æ‘„åƒå¤´é”™è¯¯:', error);
                    document.getElementById('gestureStatus').textContent = 'âŒ æ‘„åƒå¤´å¤±è´¥';
                }
            }
            
            startSimpleHandDetection() {
                if (!this.handTrackingActive || !this.video) return;
                
                const detectFrame = () => {
                    if (!this.video.videoWidth) {
                        requestAnimationFrame(detectFrame);
                        return;
                    }
                    
                    this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
                    const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                    
                    let brightPixels = 0;
                    let totalX = 0;
                    let totalY = 0;
                    
                    for (let i = 0; i < imageData.data.length; i += 4) {
                        const brightness = (imageData.data[i] + imageData.data[i+1] + imageData.data[i+2]) / 3;
                        if (brightness > 100) {
                            brightPixels++;
                            const pixelIndex = i / 4;
                            totalX += pixelIndex % this.canvas.width;
                            totalY += Math.floor(pixelIndex / this.canvas.width);
                        }
                    }
                    
                    if (brightPixels > this.params.handDetectionThreshold) {
                        const handX = totalX / brightPixels / this.canvas.width;
                        const handY = totalY / brightPixels / this.canvas.height;
                        
                        this.lastHandX = this.lastHandX * 0.7 + handX * 0.3;
                        this.lastHandY = this.lastHandY * 0.7 + handY * 0.3;
                        
                        const targetRotationY = (this.lastHandX - 0.5) * Math.PI * 1.5;
                        const targetRotationX = (this.lastHandY - 0.5) * Math.PI * 0.75;
                        
                        this.particleGroup.rotation.y += (targetRotationY - this.particleGroup.rotation.y) * 0.1;
                        this.particleGroup.rotation.x += (targetRotationX - this.particleGroup.rotation.x) * 0.1;
                        
                        const now = Date.now();
                        if (now - this.gestureCooldown > 1200) {
                            const areaRatio = brightPixels / (this.canvas.width * this.canvas.height);
                            
                            if (areaRatio > 0.25) {
                                document.getElementById('gestureStatus').textContent = 'ğŸ‘‹ å¼ å¼€æ‰‹æŒ';
                                if (this.mode !== 'scattered') {
                                    this.scatterParticles();
                                    this.gestureCooldown = now;
                                }
                            } else if (areaRatio > 0.05 && areaRatio < 0.15) {
                                document.getElementById('gestureStatus').textContent = 'âœŠ æ¡æ‹³';
                                if (this.mode !== 'tree') {
                                    this.formTree();
                                    this.gestureCooldown = now;
                                }
                            } else {
                                document.getElementById('gestureStatus').textContent = 'ğŸ–ï¸ æ‰‹æŒç§»åŠ¨ä¸­';
                            }
                        }
                    } else {
                        document.getElementById('gestureStatus').textContent = 'ğŸ‘† è¯·å°†æ‰‹æ”¾å…¥ç”»é¢';
                    }
                    
                    if (this.handTrackingActive) {
                        requestAnimationFrame(detectFrame);
                    }
                };
                
                detectFrame();
            }
            
            startCamera() {
                if (!this.handTrackingActive) {
                    this.setupCamera();
                }
            }
            
            // ==================== é¼ æ ‡æ§åˆ¶ ====================
            setupMouseControls() {
                const canvas = this.renderer.domElement;
                let isDragging = false;
                let lastX = 0, lastY = 0;
                
                canvas.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    lastX = e.clientX;
                    lastY = e.clientY;
                    canvas.style.cursor = 'grabbing';
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const deltaX = e.clientX - lastX;
                    const deltaY = e.clientY - lastY;
                    
                    this.particleGroup.rotation.y += deltaX * 0.01;
                    this.particleGroup.rotation.x += deltaY * 0.01;
                    
                    lastX = e.clientX;
                    lastY = e.clientY;
                });
                
                canvas.addEventListener('mouseup', () => {
                    isDragging = false;
                    canvas.style.cursor = 'default';
                });
                
                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    this.particleGroup.scale.multiplyScalar(e.deltaY > 0 ? 0.95 : 1.05);
                });
                
                canvas.addEventListener('dblclick', () => {
                    if (this.mode === 'tree') {
                        this.scatterParticles();
                    } else {
                        this.formTree();
                    }
                });
                
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            // ==================== åŠ¨ç”»å¾ªç¯ ====================
            animate() {
                requestAnimationFrame(() => this.animate());
                
                const time = Date.now() * 0.001;
                
                // æ›´æ–°ç²’å­
                for (let i = 0; i < this.particles.length; i++) {
                    const particle = this.particles[i];
                    const targetPos = particle.userData.targetPosition;
                    
                    particle.position.lerp(targetPos, 0.08);
                    
                    if (this.mode === 'tree') {
                        const offset = particle.userData.speed;
                        particle.position.x += Math.sin(time * offset) * 0.03;
                        particle.position.y += Math.cos(time * offset * 0.7) * 0.03;
                    }
                    
                    particle.rotation.x += 0.008;
                    particle.rotation.y += 0.012;
                }
                
                // æ›´æ–°ç…§ç‰‡å¡ç‰‡
                if (this.isPhotoWallActive) {
                    this.photoCards.forEach((card, index) => {
                        // ç…§ç‰‡å¢™æ¨¡å¼ï¼šå›´ç»•åœ£è¯æ ‘æ—‹è½¬
                        const angle = card.userData.originalAngle + time * 0.2;
                        const radius = this.photoWallRadius;
                        const bobHeight = Math.sin(time * card.userData.bobSpeed + index) * card.userData.bobHeight;
                        
                        const targetPos = new THREE.Vector3(
                            Math.cos(angle) * radius,
                            6 + bobHeight,
                            Math.sin(angle) * radius
                        );
                        
                        card.position.lerp(targetPos, 0.05);
                        card.lookAt(0, 6, 0);
                        card.rotation.y += card.userData.rotationSpeed;
                    });
                } else {
                    // æ™®é€šæ¨¡å¼ï¼šç¼“æ…¢æµ®åŠ¨
                    this.photoCards.forEach((card, index) => {
                        const bobHeight = Math.sin(time * 0.3 + index) * 0.2;
                        card.position.y += bobHeight * 0.01;
                        card.rotation.y += 0.001;
                    });
                }
                
                // è‡ªåŠ¨æ—‹è½¬
                if (this.isRotating && this.mode === 'tree' && !this.handTrackingActive) {
                    this.particleGroup.rotation.y += 0.0015;
                }
                
                // æ¸²æŸ“
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // å…¨å±€å˜é‡å’Œå‡½æ•°
        let tree;
        
        window.addEventListener('DOMContentLoaded', () => {
            tree = new PhotoChristmasTree();
            window.tree = tree;
            
            console.log("âœ… å¸¦ç…§ç‰‡å¢™çš„åœ£è¯æ ‘å·²åŠ è½½ï¼");
            console.log("ğŸ“¸ åŠŸèƒ½è¯´æ˜:");
            console.log("1. ä¸Šä¼ ç…§ç‰‡åˆ›å»º3Dç…§ç‰‡å¢™");
            console.log("2. æ‰‹åŠ¿æ§åˆ¶åœ£è¯æ ‘");
            console.log("3. ç‚¹å‡»ç…§ç‰‡èšç„¦æŸ¥çœ‹");
        });
        
        function startCamera() {
            if (tree) {
                tree.startCamera();
            }
        }
        
        // é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', (e) => {
            if (e.key === 'c' || e.key === 'C') startCamera();
            if (e.key === ' ') {
                if (tree.mode === 'tree') tree.scatterParticles();
                else tree.formTree();
            }
            if (e.key === 'p' || e.key === 'P') {
                tree.togglePhotoWall();
            }
        });
    </script>
</body>
</html>